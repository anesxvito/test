<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Skibidi Toilet 3D Adventure</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background: #1a1a2e;
            color: white;
        }
        
        #game-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            z-index: 100;
        }
        
        .ui-element {
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 25px;
            border-radius: 15px;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        #score {
            background: linear-gradient(45deg, #ff6b6b, #ff8787);
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.4);
        }
        
        #coins {
            background: linear-gradient(45deg, #ffd93d, #ffed4b);
            box-shadow: 0 4px 15px rgba(255, 217, 61, 0.4);
        }
        
        #start-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 200;
        }
        
        #start-screen h1 {
            font-size: 60px;
            margin-bottom: 20px;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #ffe66d);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: rainbow 3s ease-in-out infinite;
        }
        
        @keyframes rainbow {
            0%, 100% { filter: hue-rotate(0deg); }
            50% { filter: hue-rotate(180deg); }
        }
        
        .btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            border: none;
            color: white;
            padding: 20px 50px;
            font-size: 24px;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            margin: 10px;
        }
        
        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            font-size: 18px;
            opacity: 0.8;
        }
        
        #game-over {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border-radius: 20px;
            z-index: 300;
        }
        
        #game-over h2 {
            font-size: 48px;
            margin-bottom: 20px;
            color: #ff6b6b;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="ui-overlay">
            <div class="ui-element" id="score">Score: 0</div>
            <div class="ui-element" id="coins">Coins: 0</div>
        </div>
        
        <div id="start-screen">
            <h1>ðŸš½ SKIBIDI TOILET 3D ðŸš½</h1>
            <p style="font-size: 20px; margin-bottom: 30px;">Collect coins and avoid obstacles!</p>
            <button class="btn" onclick="startGame()">PLAY NOW</button>
        </div>
        
        <div id="controls">
            Use WASD or Arrow Keys to move â€¢ SPACE to jump
        </div>
        
        <div id="game-over">
            <h2>GAME OVER!</h2>
            <p style="font-size: 24px; margin-bottom: 20px;">Final Score: <span id="final-score">0</span></p>
            <button class="btn" onclick="restartGame()">PLAY AGAIN</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer;
        let player, playerVelocity = { x: 0, y: 0, z: 0 };
        let coins = [], obstacles = [];
        let score = 0, coinCount = 0;
        let gameRunning = false;
        let clock = new THREE.Clock();
        let mixer;
        
        const keys = {};
        const PLAYER_SPEED = 0.15;
        const JUMP_FORCE = 0.3;
        const GRAVITY = -0.015;
        const GROUND_Y = 0;
        
        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x1a1a2e, 10, 50);
            
            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 8, 15);
            camera.lookAt(0, 0, 0);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('game-container').appendChild(renderer.domElement);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);
            
            // Ground
            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x2d3561,
                roughness: 0.8
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Grid pattern on ground
            const gridHelper = new THREE.GridHelper(100, 50, 0x4ecdc4, 0x4ecdc4);
            gridHelper.material.opacity = 0.2;
            gridHelper.material.transparent = true;
            scene.add(gridHelper);
            
            createPlayer();
            
            // Event listeners
            document.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
            document.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);
            window.addEventListener('resize', onWindowResize);
        }
        
        function createPlayer() {
            const playerGroup = new THREE.Group();
            
            // Toilet bowl (main body)
            const bowlGeometry = new THREE.CylinderGeometry(1, 0.8, 1.5, 8);
            const bowlMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffffff,
                metalness: 0.3,
                roughness: 0.5
            });
            const bowl = new THREE.Mesh(bowlGeometry, bowlMaterial);
            bowl.position.y = 0.75;
            bowl.castShadow = true;
            playerGroup.add(bowl);
            
            // Toilet seat
            const seatGeometry = new THREE.TorusGeometry(0.9, 0.15, 8, 16);
            const seatMaterial = new THREE.MeshStandardMaterial({ color: 0xffeb3b });
            const seat = new THREE.Mesh(seatGeometry, seatMaterial);
            seat.position.y = 1.5;
            seat.rotation.x = -Math.PI / 2;
            playerGroup.add(seat);
            
            // Eyes
            const eyeGeometry = new THREE.SphereGeometry(0.15, 16, 16);
            const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.3, 1.2, 0.8);
            playerGroup.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.3, 1.2, 0.8);
            playerGroup.add(rightEye);
            
            // Toilet tank (back)
            const tankGeometry = new THREE.BoxGeometry(1.2, 1, 0.4);
            const tankMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const tank = new THREE.Mesh(tankGeometry, tankMaterial);
            tank.position.set(0, 1.5, -0.7);
            playerGroup.add(tank);
            
            player = playerGroup;
            player.position.y = GROUND_Y;
            scene.add(player);
        }
        
        function createCoin(x, z) {
            const coinGroup = new THREE.Group();
            
            const coinGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.1, 16);
            const coinMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffd700,
                metalness: 0.8,
                roughness: 0.2,
                emissive: 0xffd700,
                emissiveIntensity: 0.3
            });
            const coin = new THREE.Mesh(coinGeometry, coinMaterial);
            coin.rotation.z = Math.PI / 2;
            coin.castShadow = true;
            coinGroup.add(coin);
            
            // Star symbol on coin
            const starShape = new THREE.Shape();
            const starPoints = 5;
            const innerRadius = 0.2;
            const outerRadius = 0.4;
            
            for(let i = 0; i < starPoints * 2; i++) {
                const angle = (i / (starPoints * 2)) * Math.PI * 2;
                const radius = i % 2 === 0 ? outerRadius : innerRadius;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                if(i === 0) starShape.moveTo(x, y);
                else starShape.lineTo(x, y);
            }
            
            const starGeometry = new THREE.ShapeGeometry(starShape);
            const starMaterial = new THREE.MeshStandardMaterial({ color: 0xffeb3b });
            const star = new THREE.Mesh(starGeometry, starMaterial);
            star.position.z = 0.06;
            coinGroup.add(star);
            
            coinGroup.position.set(x, 1, z);
            coinGroup.userData = { rotationSpeed: 0.05 };
            coins.push(coinGroup);
            scene.add(coinGroup);
        }
        
        function createObstacle(x, z) {
            const obstacleGroup = new THREE.Group();
            
            // Spike obstacle
            const coneGeometry = new THREE.ConeGeometry(0.8, 2, 4);
            const coneMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xff4757,
                emissive: 0xff4757,
                emissiveIntensity: 0.2
            });
            const cone = new THREE.Mesh(coneGeometry, coneMaterial);
            cone.position.y = 1;
            cone.castShadow = true;
            obstacleGroup.add(cone);
            
            // Warning stripes
            const stripeGeometry = new THREE.BoxGeometry(1.6, 0.2, 1.6);
            const stripeMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffc048,
                emissive: 0xffc048,
                emissiveIntensity: 0.3
            });
            const stripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
            stripe.position.y = 0.1;
            obstacleGroup.add(stripe);
            
            obstacleGroup.position.set(x, 0, z);
            obstacleGroup.userData = { rotationSpeed: 0.02 };
            obstacles.push(obstacleGroup);
            scene.add(obstacleGroup);
        }
        
        function spawnItems() {
            // Spawn coins
            if(Math.random() < 0.05 && coins.length < 10) {
                const angle = Math.random() * Math.PI * 2;
                const distance = 10 + Math.random() * 20;
                createCoin(
                    Math.cos(angle) * distance,
                    Math.sin(angle) * distance
                );
            }
            
            // Spawn obstacles
            if(Math.random() < 0.03 && obstacles.length < 5) {
                const angle = Math.random() * Math.PI * 2;
                const distance = 10 + Math.random() * 20;
                createObstacle(
                    Math.cos(angle) * distance,
                    Math.sin(angle) * distance
                );
            }
        }
        
        function updatePlayer() {
            // Movement
            if(keys['a'] || keys['arrowleft']) {
                player.position.x -= PLAYER_SPEED;
                player.rotation.y = Math.PI / 2;
            }
            if(keys['d'] || keys['arrowright']) {
                player.position.x += PLAYER_SPEED;
                player.rotation.y = -Math.PI / 2;
            }
            if(keys['w'] || keys['arrowup']) {
                player.position.z -= PLAYER_SPEED;
                player.rotation.y = Math.PI;
            }
            if(keys['s'] || keys['arrowdown']) {
                player.position.z += PLAYER_SPEED;
                player.rotation.y = 0;
            }
            
            // Jump
            if(keys[' '] && player.position.y <= GROUND_Y + 0.1) {
                playerVelocity.y = JUMP_FORCE;
            }
            
            // Apply gravity
            playerVelocity.y += GRAVITY;
            player.position.y += playerVelocity.y;
            
            // Ground collision
            if(player.position.y < GROUND_Y) {
                player.position.y = GROUND_Y;
                playerVelocity.y = 0;
            }
            
            // Boundaries
            const boundary = 40;
            player.position.x = Math.max(-boundary, Math.min(boundary, player.position.x));
            player.position.z = Math.max(-boundary, Math.min(boundary, player.position.z));
            
            // Camera follow
            camera.position.x = player.position.x;
            camera.position.z = player.position.z + 15;
            camera.lookAt(player.position);
        }
        
        function checkCollisions() {
            const playerBox = new THREE.Box3().setFromObject(player);
            
            // Coin collection
            coins.forEach((coin, index) => {
                const coinBox = new THREE.Box3().setFromObject(coin);
                if(playerBox.intersectsBox(coinBox)) {
                    scene.remove(coin);
                    coins.splice(index, 1);
                    coinCount++;
                    score += 100;
                    updateUI();
                    
                    // Particle effect
                    createParticles(coin.position, 0xffd700);
                }
            });
            
            // Obstacle collision
            obstacles.forEach(obstacle => {
                const obstacleBox = new THREE.Box3().setFromObject(obstacle);
                if(playerBox.intersectsBox(obstacleBox)) {
                    gameOver();
                }
            });
        }
        
        function createParticles(position, color) {
            const particleCount = 20;
            const particles = [];
            
            for(let i = 0; i < particleCount; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const particleMaterial = new THREE.MeshBasicMaterial({ color: color });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                particle.position.copy(position);
                particle.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.3,
                    Math.random() * 0.3,
                    (Math.random() - 0.5) * 0.3
                );
                particle.lifetime = 1;
                
                scene.add(particle);
                particles.push(particle);
            }
            
            // Animate particles
            const animateParticles = () => {
                particles.forEach((particle, index) => {
                    particle.position.add(particle.velocity);
                    particle.velocity.y -= 0.01;
                    particle.lifetime -= 0.02;
                    particle.material.opacity = particle.lifetime;
                    particle.material.transparent = true;
                    
                    if(particle.lifetime <= 0) {
                        scene.remove(particle);
                        particles.splice(index, 1);
                    }
                });
                
                if(particles.length > 0) {
                    requestAnimationFrame(animateParticles);
                }
            };
            
            animateParticles();
        }
        
        function updateUI() {
            document.getElementById('score').textContent = `Score: ${score}`;
            document.getElementById('coins').textContent = `Coins: ${coinCount}`;
        }
        
        function animate() {
            if(!gameRunning) return;
            
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            
            updatePlayer();
            checkCollisions();
            spawnItems();
            
            // Animate coins
            coins.forEach(coin => {
                coin.rotation.y += coin.userData.rotationSpeed;
                coin.position.y = 1 + Math.sin(Date.now() * 0.002) * 0.2;
            });
            
            // Animate obstacles
            obstacles.forEach(obstacle => {
                obstacle.rotation.y += obstacle.userData.rotationSpeed;
            });
            
            // Increase score over time
            score += 1;
            updateUI();
            
            renderer.render(scene, camera);
        }
        
        function startGame() {
            document.getElementById('start-screen').style.display = 'none';
            gameRunning = true;
            score = 0;
            coinCount = 0;
            updateUI();
            animate();
        }
        
        function gameOver() {
            gameRunning = false;
            document.getElementById('final-score').textContent = score;
            document.getElementById('game-over').style.display = 'block';
        }
        
        function restartGame() {
            // Clear existing items
            coins.forEach(coin => scene.remove(coin));
            obstacles.forEach(obstacle => scene.remove(obstacle));
            coins = [];
            obstacles = [];
            
            // Reset player
            player.position.set(0, GROUND_Y, 0);
            playerVelocity = { x: 0, y: 0, z: 0 };
            
            // Reset game state
            document.getElementById('game-over').style.display = 'none';
            startGame();
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Initialize game
        init();
    </script>
</body>
</html>